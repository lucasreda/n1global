Criar editor visual nativo PageModelV4 que renderize EXATAMENTE o HTML original importado, com 100% de capacidade de edição.
REQUISITOS:
✅ Conversor HTML→V4 JÁ existe e funciona perfeitamente (100% precisão)
✅ Pode IGNORAR compatibilidade V2 (usuário apagará páginas antigas)
✅ Renderização visual DEVE ser idêntica ao HTML original
✅ TODAS as funcionalidades do editor atual DEVEM funcionar (AI, templates, inspector, etc.)
═══════════════════════════════════════════════════════════════════════
ETAPA 1: ATUALIZAR VisualEditor - REMOVER CONVERSÃO V4→V2
════════════════════════════════════════════════════════════════════════
PROBLEMA ATUAL:
- VisualEditor chama ensurePageModelV2(model)
- Isso converte V4→V2 e perde toda a estrutura
- Resultado: tela vazia no editor
SOLUÇÃO:
Aceitar PageModelV4 diretamente, SEM conversão
ARQUIVO: client/src/components/page-builder/VisualEditor.tsx
MUDANÇA:
```typescript
// ❌ ANTES (causava o problema)
const pageModel = ensurePageModelV2(landingPage.model);
// ✅ DEPOIS (usa V4 nativo)
const pageModel = landingPage.model as PageModelV4;
if (!pageModel || pageModel.version !== '4.0') {
  return <div>Apenas PageModelV4 é suportado</div>;
}
CRITÉRIOS:
✓ VisualEditor aceita APENAS PageModelV4
✓ Remove chamada a ensurePageModelV2
✓ Valida model.version === '4.0'

═══════════════════════════════════════════════════════════════════════

ETAPA 2: CRIAR RENDERIZADOR V4 NATIVO
════════════════════════════════════════════════════════════════════════

ARQUIVO: client/src/components/page-builder/PageModelV4Renderer.tsx

Criar componente que renderiza nodes V4 recursivamente:

export function PageModelV4Renderer({ model }: { model: PageModelV4 }) {
  return (
    <div className="page-frame">
      {model.nodes.map(node => (
        <PageNodeV4Renderer key={node.id} node={node} />
      ))}
    </div>
  );
}
function PageNodeV4Renderer({ node }: { node: PageNodeV4 }) {
  const { selectedNodeId } = useEditorStore();
  const isSelected = selectedNodeId === node.id;
  
  // Tag HTML exata (header, section, nav, div, etc.)
  const Tag = node.tag as keyof JSX.IntrinsicElements;
  
  // Styles do breakpoint ativo
  const [breakpoint] = useState<'desktop' | 'tablet' | 'mobile'>('desktop');
  const styles = node.styles?.[breakpoint] || {};
  
  // Handler de clique para seleção
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    useEditorStore.setState({ selectedNodeId: node.id });
  };
  
  return (
    <Tag
      data-node-id={node.id}
      className={cn(
        node.classNames?.join(' '),
        isSelected && 'ring-2 ring-blue-500'
      )}
      style={styles}
      onClick={handleClick}
      {...node.attributes}
    >
      {/* Text content */}
      {node.textContent}
      
      {/* Children recursivos */}
      {node.children?.map(child => (
        <PageNodeV4Renderer key={child.id} node={child} />
      ))}
    </Tag>
  );
}
CRITÉRIOS:
✓ Renderiza tag HTML EXATA (preserva semântica)
✓ Aplica styles, classNames, attributes corretamente
✓ Suporta nesting INFINITO (children → children → children)
✓ Clique seleciona node para edição
✓ Visual ring quando selecionado

═══════════════════════════════════════════════════════════════════════

ETAPA 3: ATUALIZAR PageFrame
════════════════════════════════════════════════════════════════════════

ARQUIVO: client/src/components/page-builder/PageFrame.tsx

Usar o novo renderizador V4:

export function PageFrame() {
  const { landingPage } = useEditorStore();
  const model = landingPage.model as PageModelV4;
  
  return <PageModelV4Renderer model={model} />;
}
CRITÉRIOS:
✓ PageFrame delega para PageModelV4Renderer
✓ Remove TODA lógica V2 antiga

═══════════════════════════════════════════════════════════════════════

ETAPA 4: ATUALIZAR LayersPanel PARA V4
════════════════════════════════════════════════════════════════════════

ARQUIVO: client/src/components/page-builder/LayersPanel.tsx

Mostrar hierarquia V4 recursiva:

export function LayersPanel() {
  const { landingPage } = useEditorStore();
  const model = landingPage.model as PageModelV4;
  
  return (
    <div className="layers-panel">
      {model.nodes.map(node => (
        <LayerNodeV4 key={node.id} node={node} depth={0} />
      ))}
    </div>
  );
}
function LayerNodeV4({ node, depth }: { node: PageNodeV4; depth: number }) {
  const [expanded, setExpanded] = useState(true);
  const { selectedNodeId } = useEditorStore();
  const hasChildren = node.children && node.children.length > 0;
  
  return (
    <div>
      <div
        className={cn(
          'flex items-center gap-2 px-2 py-1 hover:bg-gray-100 cursor-pointer',
          selectedNodeId === node.id && 'bg-blue-100'
        )}
        style={{ paddingLeft: depth * 20 }}
        onClick={() => {
          useEditorStore.setState({ selectedNodeId: node.id });
          if (hasChildren) setExpanded(!expanded);
        }}
      >
        {hasChildren && (
          <span className="w-4">{expanded ? '▼' : '▶'}</span>
        )}
        
        <span className="text-purple-600">&lt;{node.tag}&gt;</span>
        <span className="text-sm text-gray-500 truncate">
          {node.textContent?.substring(0, 30)}
        </span>
      </div>
      
      {expanded && hasChildren && (
        node.children!.map(child => (
          <LayerNodeV4 key={child.id} node={child} depth={depth + 1} />
        ))
      )}
    </div>
  );
}
CRITÉRIOS:
✓ Mostra hierarquia recursiva completa
✓ Exibe tag HTML real (<header>, <section>, etc.)
✓ Clique seleciona node
✓ Expandir/colapsar funciona
✓ Highlight do node selecionado

═══════════════════════════════════════════════════════════════════════

ETAPA 5: ATUALIZAR AdvancedPropertiesPanel
════════════════════════════════════════════════════════════════════════

ARQUIVO: client/src/components/page-builder/AdvancedPropertiesPanel.tsx

Editar propriedades V4:

export function AdvancedPropertiesPanel() {
  const { landingPage, selectedNodeId } = useEditorStore();
  const model = landingPage.model as PageModelV4;
  
  const node = selectedNodeId ? findNodeInTree(model.nodes, selectedNodeId) : null;
  
  if (!node) {
    return <EmptyState message="Selecione um elemento para editar" />;
  }
  
  const [breakpoint, setBreakpoint] = useState<'desktop' | 'tablet' | 'mobile'>('desktop');
  
  const updateNodeStyles = (newStyles: Record<string, any>) => {
    if (!node.styles) node.styles = {};
    node.styles[breakpoint] = { ...node.styles[breakpoint], ...newStyles };
    
    // Trigger re-render
    useEditorStore.setState({ landingPage: { ...landingPage } });
  };
  
  return (
    <div className="properties-panel">
      {/* Breakpoint selector */}
      <BreakpointTabs value={breakpoint} onChange={setBreakpoint} />
      
      {/* Tag editor */}
      <TagEditor 
        tag={node.tag}
        onChange={newTag => {
          node.tag = newTag;
          useEditorStore.setState({ landingPage: { ...landingPage } });
        }}
      />
      
      {/* Style editor */}
      <StyleEditor
        styles={node.styles?.[breakpoint] || {}}
        onChange={updateNodeStyles}
      />
      
      {/* Attributes editor */}
      <AttributesEditor
        attributes={node.attributes || {}}
        onChange={newAttrs => {
          node.attributes = newAttrs;
          useEditorStore.setState({ landingPage: { ...landingPage } });
        }}
      />
      
      {/* Text content editor (se for text node) */}
      {node.textContent !== undefined && (
        <TextEditor
          value={node.textContent}
          onChange={newText => {
            node.textContent = newText;
            useEditorStore.setState({ landingPage: { ...landingPage } });
          }}
        />
      )}
    </div>
  );
}
// Helper: Buscar node na tree recursivamente
function findNodeInTree(nodes: PageNodeV4[], id: string): PageNodeV4 | null {
  for (const node of nodes) {
    if (node.id === id) return node;
    if (node.children) {
      const found = findNodeInTree(node.children, id);
      if (found) return found;
    }
  }
  return null;
}
CRITÉRIOS:
✓ Inspector edita responsive styles (desktop/tablet/mobile)
✓ Edita tag HTML (<div> → <section>)
✓ Edita attributes (href, src, alt, etc.)
✓ Edita text content
✓ Mudanças refletem instantaneamente

═══════════════════════════════════════════════════════════════════════

ETAPA 6: DRAG & DROP V4
════════════════════════════════════════════════════════════════════════

ARQUIVO: client/src/components/page-builder/ElementsToolbar.tsx

Criar novos elementos V4:

const newElements = [
  { type: 'heading', tag: 'h1', label: 'Heading' },
  { type: 'paragraph', tag: 'p', label: 'Paragraph' },
  { type: 'button', tag: 'button', label: 'Button' },
  { type: 'container', tag: 'div', label: 'Container' },
  { type: 'image', tag: 'img', label: 'Image' },
];
function handleDrop(parentNodeId: string, elementData: any) {
  const { landingPage } = useEditorStore.getState();
  const model = landingPage.model as PageModelV4;
  
  const newNode: PageNodeV4 = {
    id: generateId(),
    type: elementData.type as NodeType,
    tag: elementData.tag,
    textContent: elementData.type === 'heading' ? 'New Heading' : 
                 elementData.type === 'paragraph' ? 'New paragraph' : undefined,
    styles: {
      desktop: {
        padding: '1rem',
        margin: '0.5rem 0',
      }
    }
  };
  
  // Encontrar parent e adicionar child
  const parentNode = findNodeInTree(model.nodes, parentNodeId);
  if (parentNode) {
    if (!parentNode.children) parentNode.children = [];
    parentNode.children.push(newNode);
    
    useEditorStore.setState({ landingPage: { ...landingPage } });
  }
}
CRITÉRIOS:
✓ Arrasta elementos da toolbar
✓ Solta em qualquer container V4
✓ Cria PageNodeV4 com propriedades corretas
✓ Adiciona em parent.children

═══════════════════════════════════════════════════════════════════════

ETAPA 7: SALVAR MODELO V4
════════════════════════════════════════════════════════════════════════

Garantir que o modelo V4 seja salvo corretamente:

async function saveModel() {
  const { landingPage } = useEditorStore.getState();
  const model = landingPage.model as PageModelV4;
  
  await fetch(`/api/affiliate/landing-pages/${landingPage.id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ model })
  });
}
CRITÉRIOS:
✓ Salva PageModelV4 sem conversões
✓ Preserva TODA estrutura V4 (nodes, styles, attributes)

═══════════════════════════════════════════════════════════════════════

VALIDAÇÃO FINAL
════════════════════════════════════════════════════════════════════════

TESTE COMPLETO:

Importar HTML do VitaPlus que você forneceu
Converter para V4 (já funciona perfeitamente)
Abrir no editor visual
VERIFICAR: Visual renderizado = HTML original? ✓
Selecionar elemento no editor
Editar estilo (ex: mudar cor, padding)
Adicionar novo elemento via drag & drop
Editar texto
Salvar
Reabrir → tudo preservado? ✓
CRITÉRIOS SUCESSO:
✓ HTML importado renderiza IDÊNTICO no editor
✓ Seleção de elementos funciona
✓ Inspector edita tudo (styles, attributes, text)
✓ Drag & drop adiciona elementos
✓ Layers panel mostra hierarquia completa
✓ Salvar/carregar preserva 100% da estrutura
✓ ZERO conversões V4→V2 no código

═══════════════════════════════════════════════════════════════════════

ARQUIVOS A MODIFICAR (RESUMO):

VisualEditor.tsx - Remove conversão V4→V2
PageModelV4Renderer.tsx - NOVO renderizador nativo
PageFrame.tsx - Usa novo renderizador
LayersPanel.tsx - Hierarquia V4 recursiva
AdvancedPropertiesPanel.tsx - Edita propriedades V4
ElementsToolbar.tsx - Drag & drop V4
shared/pageModelAdapter.ts - Remover funções V2 (opcional)